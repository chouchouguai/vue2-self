{"version":3,"file":"vue.js","sources":["../src/compile/generate.js","../src/compile/parseAst.js","../src/compile/index.js","../src/utils/index.js","../src/global-api/index.js","../src/utils/nextTick.js","../src/observe/arr.js","../src/observe/dep.js","../src/observe/index.js","../src/observe/watcher.js","../src/initState.js","../src/vnode/patch.js","../src/lifecycle.js","../src/init.js","../src/vnode/index.js","../src/index.js"],"sourcesContent":["/**\n * <div id=\"app\" >Hello {{msg}} </div>\n * render(){ //_c解析标签,_v解析文本,_s解析插值表达式\n *   return _c('div',{id:app},_v('hello'+_s(msg)),_c())\n * }\n * 本文件的主要任务就是获取render函数的字符串部分\n * \n */\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;// 匹配默认 {{}}\n/**\n * 处理属性ast中 {name:'style',value: \"color:red;font-size: 20px\"\n * return: {style:{color:'red',font-size: '20px'}}\n * */\nfunction genProps(attrs) {\n    let str = '';\n    for (let i = 0; i < attrs.length; i++) {\n        let attr = attrs[i];//{name:'style',value: \"color:red;font-size: 20px\"\n        if (attr.name === 'style') {//获取是否是行内样式\n            let obj = {};\n            attr.value.split(';').forEach(item => {//[\"color:'red'\"\",\"font-size:'20px'\"]\n                let [key, value] = item.split(\":\");\n                obj[key] = value;//obj[color]='red',obj['font-size']=\"20px\"\n            });\n            attr.value = obj;\n        }\n        str += `${attr.name}:${JSON.stringify(attr.value)},`;//str+='style:\"{color:red,font-size:20px}\"'\n    }\n    return `{${str.slice(0, -1)}}`\n}\n//处理所有子节点们\n/**\n * \n * @param {*} el \n * @returns \n */\nfunction genChildren(el) {\n    let children = el.children;//children:[{type: 3, text: 'Hello {{msg}} '}]\n    // console.log('---children', children)\n    if (children) {\n        return children.map(child => gen(child)).join(',')//_v('hello'),_v\n    }\n}\n/**\n * 处理子节点\n * @param {*} node\n */\nfunction gen(node) {\n    if (node.type == 1) {//若是元素节点\n        return generate(node)\n    } else {//非元素节点，本处默认就是文本 1)普通文本 2）{{msg}}\n        let text = node.text;//获取文本内容 hello {{msg}}\n        if (!defaultTagRE.test(text)) {//检查文本中是否无插值表达式\n            return `_v(${JSON.stringify(text)})`;//解析普通文本用_v()函数\n        }\n        //有{{}}\n        let tokens = [];//存放每一段的代码\n        let lastindex = defaultTagRE.lastIndex = 0;//若没有给lastIndex(下次匹配的起始位置)赋值，则defaultTagRE.test只能匹配一个字符串\n        let match\n        while (match = defaultTagRE.exec(text)) {//match=[\"{{msg}}\",\" msg  \",index:7,input:\" hello {{ msg }} \",groups:undefined]\n            let index = match.index;//当前符合正则的下标位置\n            if (index > lastindex) {\n                tokens.push(JSON.stringify(text.slice(lastindex, index)));//截取文本中(从0到{{ 的内容)--普通文本\" hello \"\n            }\n            // {{msg}}\n            tokens.push(`_s(${match[1].trim()})`)\n            //lastindex = 当前下标 + 表达式的长度 如 hello {{ msg }},haha\n            lastindex = index + match[0].length;\n            //\n        }\n        if (lastindex < text.length) {//{{msg}}后面还有 haha ,msg}}最后一个右括号的下标 < text文本的长度\n            tokens.push(JSON.stringify(text.slice(lastindex)))//取出 haha\n        }\n        return `_v(${tokens.join(\"+\")})`\n    }\n}\n\nexport function generate(el) {\n    //注意属性 {id:app,style:{color:red;font-size:12px}}\n    // console.log('---fennerate',el)\n    let children = genChildren(el);\n    //_c(根节点,参数对象||null,子节点||null,)\n    let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'}${children ? `,${children}` : ''})`;\n    // console.log('---code',code)\n    return code;\n}","/**\n * ps：ast语法树 (abstract syntax tree 抽象语法树)  vnode(虚拟节点)\n * 如：页面结构 <div id=\"#app\">hello {{msg}}<span></span></div>\n * 对应ast为：\n * {\n * tag:'div',\n * attrs:[{id:'app'}],\n * children:[{tag:null,text:'hello'},{tag:'span'}]\n */\n\n\n/** 以下为vue2中区别标签相关的正则 */\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`// 标签名称 ---如 div\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;// 如  <span:xx>\nconst startTagOpen = new RegExp(`^<${qnameCapture}`);// 标签开头的正则 捕获的内容是标签名    如 <div\n\nconst attribute =\n  /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // \\s所有空白符，包括换行 id=\"app\"\nconst startTagClose = /^\\s*(\\/?)>/;// 匹配标签结束的 >   ps: startTagOpen + attribute + startTagClose = \"<div id=\"app\" >\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;// 匹配默认 {{}}\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);// 匹配标签结尾 </div>\n\n\n/**\n * \n * @param {*} html - 本次需要转换的html -p33 7分25秒\n * step1:\n * 该方法是将html字符串 ->初级形态的ast\n * 经过该方法后 开始标签 <div id=\"app\"> --->  {tagName:'div',attrs:[{name:'id',value:'app'}]}\n *            文本    hello {{msg}}   --->  hello {{msg}}\n *            结束标签  </div>         --->  ['</div>', 'div', index: 0, input: '</div>', groups: undefined]\n * return :当前html的ast表示对象 (其中用parent 和 childern表示了节点间的包含关系)\n */\nexport function parseHTML(html) {// html中包含的内容只有3大类型:开始标签  文本  结束标签\n  // 将str -> ast\n  // 遍历\n  /*\n  如： <div id=\"app\"> hello {{msg}} <h1></h1> </div>\n  创建一个 ast 对象\n  根据标签名和参数 返回一个ast对象 {}\n  nodetype的类型\n  1:元素节点\n  2:属性节点\n  3:文本节点\n  */\n\n  function createASTElement(tag, attrs) {\n    return {\n      tag,//元素 div span h等\n      attrs,//属性 id class 等\n      children: [],//子节点 如div 中包含了span 则span就是自己点\n      type: 1,//nodetype的类型\n      parent: null//该元素的父元素\n    }\n  }\n  let root;//根元素\n  let createParent;//当前元素的父元素\n  //数据结构 栈:先进后出\n  let stack = [];//[div]\n\n\n  // 开始标签 <div id='app'>\n  /**\n   * \n   * @param {*} tag \n   * @param {*} attrs \n   * 将开始标签转为ast对象，并入栈 (注:end方法中 会将其出栈)\n   */\n  function start(tag, attrs) {/**传入标签名 和 参数  */\n    let element = createASTElement(tag, attrs);\n    if (!root) {\n      root = element;\n    }\n    createParent = element;\n    stack.push(element);\n  }\n  // 获取文本 {{msg}}\n  function charts(text) {\n    //    console.log('文本', text)\n    //替换 空格\n    text = text.replace(/\\s/g, '');//\n    if (text) {\n      createParent.children.push({\n        type: 3,//文本类型\n        text//文本内容\n      })\n    }\n  }\n  // 结束标签 </div>\n  /**\n   * \n   * @param {*} tag \n   * 从stack中 取出最后进的元素,以及读取前一个元素 将两个元素的父子关系分别用属性parent 和childern关联起来\n   */\n  function end(tag) {\n    //    console.log('---结束标签end', tag)\n    //如此时<div><h></h></div  stack中有两个元素 [div,h]\n    let element = stack.pop();//取出栈中第一个元素 栈后进先出 pop取的就是最后进的那个 h\n    createParent = stack[stack.length - 1];//此时取出的是栈中最后进的前一个 div\n    if (createParent) {//元素的闭合\n      element.parent = createParent.tag;//{tag:h,attrs:null,type:1,parent:'div'} \n      createParent.children.push(element);//{tag:div,attrs:[{id:'app'}],type:1,children:[{tag:h,attrs:null,type:1}]}\n    }\n  }\n\n  // 如: <div id=\"app\"> hello {{msg}} <h></h> </div> \n  /** 思路 每次解析结束完成部分的html 删除 */\n  while (html) {// html 为空结束\n    // 判断标签\n    let textEnd = html.indexOf('<');\n    if (textEnd === 0) {// html以 < 开头 说明是标签\n      // 1.看是否是开始标签，与开始标签的正则startTagOpen 匹配\n      const startTagMatch = parseStartTag();//  开始标签的内容-该方法是单独定义的\n      // console.log('----startTagMatch',startTagMatch)\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs)//---开始标签的处理，根据标签名称和参数,创建root对象，当前节点对象,转为ast对象并入栈\n        continue;\n      }\n      //结束标签 ->若为结束标签</标签名>\n      let endTagMatch = html.match(endTag)//从html中匹配结束标记的正则(endTag),得到与正则匹配的文本内容\n      //    console.log('---enTagMatch',endTagMatch)\n      if (endTagMatch) {//若存在结束标签 \n        advance(endTagMatch[0].length)\n        end(endTagMatch[1])//到结束标签了 则将当前节点和其父节点关联起来,并放到root对象中去\n        continue;\n      }\n    }\n    // 文本\n    // 说明html 不是< 开头 如： hello</div> ,这个textEnd就是5\n    let text;\n    if (textEnd > 0) {\n      //  解析文本\n      //  获取文本内容 ---方案:// hello</div> 截取< 符号之前的内容(其实就是hello)\n      //  console.log('----textEnd',textEnd)\n      text = html.slice(0, textEnd);\n      //  console.log('---parseHTML',text);\n    }\n    if (text) {\n      advance(text.length)\n      charts(text)//将文本内容放入到root对象中\n    }\n    // break;\n  }\n  /**\n   * 解析开始标签\n   * @returns \n   * {\n   *  tagName:div\n   *  attrs:[\n   *    {\n   *      name:\"id\",\n   *      value:\"app\"\n   *    }\n   * ]\n   * }\n   */\n  function parseStartTag() {\n    // 子表达式指:正则表达式中用小括号包起来的表达式\n    /** match(正则表达式),若正则表达式没有全局标识/g,\n    *   则该match方法只执行一次匹配，\n    *   返回[匹配文本,与子表达式匹配的文本们...,index:匹配开始位置,input:进行匹配的字符串本身的引用] \n    *   若无结果 返回null*/\n    const start = html.match(startTagOpen);\n    // start = ['<div', 'div', index: 0, input: \"<div id='#app'>hello {{msg}}<span></span></div>\", groups: undefined]\n    if (start) {\n      // 创建ast 语法树-初级形态\n      let match = {\n        tagName: start[1],\n        attrs: []\n      }\n      advance(start[0].length)// 向前推进一步 (删除开始标签)\n      // 获取属性 -注意 属性可能有多个 需要遍历\n      let attr\n      /*\n        注意 刚才删除了开始标签 但是开始标签还有个 >  \n        比如第一次删除了开始标签<div  剩余 id='#app'> hello {{msg}} <span></span></div>\n      */\n      let end\n      /* \n        循环剩下的html -若剩余的html 不是单纯的> (html.match(startTagClose) 为true则表示仅为>) \n        并且有属性(html.match(attribute)为true表示有属性内容)\n      */\n      // console.log('---->',html.match(startTagClose))\n      //console.log('----attribute',html.match(attribute))//[' id=\"app\"', 'id', '=', 'app', undefined, undefined, index: 0, input: ' id=\"app\">\\n    Hello {{name}}\\n  </div>', groups: undefined]\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        // 将属性追加到match的attrs中 [{name:'id',value:'app'}]\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || atrr[4] || atrr[5]\n        })\n        advance(attr[0].length)\n      }\n      if (end) {\n        advance(end[0].length)\n        return match;// <div id='app'> 解析完成 返回开始节点对应的ast初级形态语法树\n      }\n    }\n  }\n  function advance(n) {\n    // 删除以及识别出的html字符串 （如 识别了<div 则删除<div,n为识别出的字符串的长度）\n    html = html.substring(n)// 从html的n位置开始截取到最后,返回截取后的内容---删除了识别出的内容\n  }\n  //  console.log('---root',root)\n  return root;\n}\n\n/**\n * 版本1综合描述：\n * * 如：页面结构 <div id=\"#app\">hello {{msg}}<h1></h1></div>\n* 最终需要获取内容为：\n* {\n* tag:'div',\n* attrs:[{id:'app'}],\n* children:[{tag:null,text:'hello'},{tag:'span'}]\n* \n * 根据文本内容字符串<div id=\"#app\">hello {{msg}}<h1></h1></div>\n * 分析:该字符串中只有3部分内容: 标签 <div> \n *                           文本 hello {{msg}}\n *                           标签 <h1> (跟div有父子关系)\n * 解析入口:parseHTML(html)\n * 只要html有内容,则一直循环\n   * 1) 若html 是以< 开头,则表示是标签(此时需要考虑 是<div> 还是</div>)-->\n   *     1.1)调用parseStartTag方法\n       *     1.1.1) 若是<div>(开始标签)\n       *        1.1.1.1)找到符合开始标签的正则(startTagOpen) <标签名 属性=\"值\"\n       *        1.1.1.2）创建对象match = {tagName:值,attrs:[]},并删除html 中 “<标签名”部分\n       *        1.1.1.3）找到不符合标签结尾(不是>),且符合参数正则的部分(其实就是标签参数),遍历创建对象,放入到match的attrs中,并删除字符串中的 attr=\"值\"部分\n       *               得到 match={tagName:值,attrs:[{name:参数名,value:参数值}]}\n       *        1.1.1.4）若找到标签结尾(\">\"这个字符串),则直接删除字符串中的“>”部分,并返回 match字段\n       *   1.2）若parseStartTag返回了内容(即match有内容),\n       *     1.2.1)则根据match的内容,创建ast对象-->start方法     \n       *       1.2.1.1） 创建ast对象 \n       *            {\n                           tag,//元素 div span h等\n                           attrs,//属性 id class 等\n                           children:[],//子节点 如div 中包含了span 则span就是自己点\n                           type:1,//nodetype的类型\n                           parent:null//该元素的父元素\n                       }\n               1.2.1.2） 若此时还没有root对象，则该ast对象为root对象\n               1.2.1.3） 当前父节点 createParent,也为该ast对象\n               1.2.1.4） 将该对象放入到ast对象栈 stack中\n           1.2.2） 继续下一轮循环,回到1)\n           1.3) 若parseStartTag没有返回内容,html匹配结束标签正则(</div>这种符合结束标签的字符串)\n           1.3.1）若匹配到结束标签\n               1.3.1.1)删除html字符串中“</div>”部分\n               1.3.1.2）将当前节点的ast与父节点关联起来，--调用end()\n               1.3.1.2.1）从stack栈中取出最后一个放入的ast对象(取出栈中就不存在该对象了),element\n               1.3.1.2.2) 获取stack中倒数第二个放入的ast对象createParent,若createParent存在,\n                       则element.parent为createParent.tag;\n                       createParent.children.push(element)\n       2) 若此时的html不是以<开头，则表示是文本部分\n       2.1）截取html中普通文本内容text\n       2.2) 若text有内容\n               2.2.1）删除html中 字符串部分如“hello {{msg}}”\n               2.2.2) 将文本内容放入root中 charts()\n               2.2.2.1) 替换text中的空字符串\n               2.2.2.2）若替换后内容仍存在,则createParent.children中追加对象\n                           {\n                               type:3//普通文本\n                               text:text//文本内容\n                           }\n   html中再无内容，则返回root对象\n */","import { generate } from \"./generate\";\nimport { parseHTML } from \"./parseAst\";\n\nexport function compileToFunction(el) {\n  // 1.将html 变成ast语法树\n  let ast = parseHTML(el);//part4 diff时发现该方法有问题 进入查看---整个只有一个parseHTML方法 其他方法都在其内部\n  // console.log('---ast',ast);\n  // 2. ast语法树变成render函数\n  // 2.1）ast语法树变成 字符串\n  \n  let code = generate(ast);//_c _v _s\n  // console.log('----ast语法变成的字符串',code);\n  // 2.2）字符串变成render函数\n  let render = new Function(`with(this){console.log('render',this);return ${code}}`);//code中的this 指向了Vue实例对象，其中msg的值相当于vue实例的msg值\n  // console.log('---render',render);\n  return render;\n}\n/**\n * \n * \n let objs = {a:1,b:2};\nwith(objs){//利用with提供作用域\n  console.log(a,b)//1,2\n}\n */\n","//对象合并\nexport const HOOKS = [\n    \"beforeCreate\",\n    \"created\",\n    \"beforeMount\",\n    \"mounted\",\n    \"beforeUpdate\",\n    \"updated\",\n    \"beforeDestory\",\n    \"destoryed\"\n];\n//策略模式 -一般如果判断if情况比较多 可以用该模式\nlet starts = {};\n//处理数据\nstarts.data = function(parentVal,childVal){\n    return childVal;\n}//合并data\n\n//part3:实现watch时先注释这三行\n// starts.computed = function(){}//合并computed\n// starts.watch = function(){}//合并watch\n// starts.methods = function(){}//合并methods\n\n\n//遍历生命周期，依次添加starts[beforeCreate],starts[created]。。等\nHOOKS.forEach(hooks=>{\n    starts[hooks] = mergeHook\n})\nfunction mergeHook(parentVal,childVal){\n    // {created:[a,b,c],watch:[a,b]}\n    if(childVal){\n        if(parentVal){\n            return parentVal.concat(childVal)\n        }else{\n            return [childVal]//[a]\n        }\n    }else{\n        return parentVal\n    }\n}\n/**\n * \n * @param {*} parent \n * @param {*} child  Vue.Mixin(参数),参数就是child\n * @returns \n */\nexport function mergeOptions(parent,child){\n    // console.log('---mergeOptions',parent,child)\n    //Vue.options = {created:[a,b,c],watch:[a,b]}\n    const options = {};\n    //如果有parent 没有 child\n    for(let key in parent){\n        mergeField(key)\n    }\n    //有child 没有 parent\n    for(let key in child){//child就是传过来的mixin 第一次child={created:function a(){}}\n        mergeField(key)\n    }\n    function mergeField(key){\n        //根据key 策略模式\n        if(starts[key]){//若存在该方法\n            options[key] = starts[key](parent[key],child[key])\n        }else{\n            options[key] = child[key]\n        }\n    }\n    // console.log('---optiosns',options)\n    return options;\n}","import { mergeOptions } from \"../utils/index\"\n/**\n * \n * @param {*} Vue \n *  源码中最终 Vue.options = {created:[a,b,c],watch:[a,b]}\n */\nexport function initGlobalApi(Vue){\n   \n    Vue.options = {}\n    Vue.Mixin = function (mixin){//mixin为Vue.Mixin(的参数=mixin)\n        // console.log('---mixin',mixin,this.options)\n        //对象的合并\n        this.options = mergeOptions(this.options,mixin)//this是当前vue实例,第一次this.options没值\n    //    console.log('---initG',Vue.options);\n    //    console.log('----Vue.$options',Vue);\n\n    }\n}","let callback = []//放回调方法\nlet pending = false;\nfunction flush(){\n    callback.forEach(cb=>cb())\n    pending = false;\n}\nlet timerFunc\n//处理兼容问题\nif(Promise){\n    timerFunc = ()=>{\n        Promise.resolve().then(flush)//异步处理\n    }\n}else if(MutationObserver){//h5 的异步方法 可以监听dom的变化 监控完毕之后再异步更新\n    let observe = new MutationObserver(flush)\n    let textNode = document.createTextNode(1);//创建文本\n    observe.observe(textNode,{characterData:true})//观测文本内容\n    timerFunc = ()=>{\n        textNode.textContent = 2;//当文本内容变成2时 执行flush方法--课堂解说\n    }\n}else if(setImmediate){//ie\n    timerFunc = ()=>{\n        setImmediate(flush)\n    }\n}\n/**nextTick :兼容不同浏览器 处理异步 */\nexport function nextTick(cb){\n    // console.log('nextT',cb);\n    //队列\n    callback.push(cb);\n    //promise.then() vue3中\n    if(!pending){\n        timerFunc()//异步方法 但是要处理兼容问题\n        pending =  true;\n    }\n}\n","/**重写数组中的方法\n * 类名.prototype ->指向原型对象,该对象中包含了所有实例共享的属性和方法\n * 对象.__proto__ ->指向该对象所属类的prototype 两个完全相等\n */\n\n\n\n//1.获取原数组中的方法\nlet oldArrayProtoMethods = Array.prototype;\n//2.继承 ->通过指定原型对象 创建新对象ArrayMethods  ;ArrayMethods.__proto__ 指向oldArrayProtoMethods\nexport let ArrayMethods = Object.create(oldArrayProtoMethods);\n//3.列出所有需要劫持的方法\nlet methods = [\n  'push',\n  'pop',\n  'unshift',\n  'shift',\n  'pop'\n];\nmethods.forEach(item=>{\n  ArrayMethods[item] = function(...args){\n    // console.log('---劫持了数组方法item',this,args)//此时的args是个数组[],会将传入的内容放入该数组中s\n    let result = oldArrayProtoMethods[item].apply(this,args);\n    //1.此时要考虑数组追加数据的情况  如原arr = [1,2]\n    //因为追加的数据可能是1)普通3==>[1,2,3]    2）对象 {a:1} ==>[1,2,{a:1}]\n    //2.考虑追加的方式 push unshift splice\n    let inserted;//追加的内容\n    switch(item){\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.splice(2);// arr.splice(开始位置,删除长度,追加内容)\n        break;\n    }\n    /*对追加的内容进行劫持observer(inserted)\n      但是因为observer方法在./index.js中,此处无法获取(别在此处引入index.js,因为index.js引入了当前文件，会造成互相引用)\n      可以考虑将observer方法绑定在当前实例对象的某个属性上 这样当前对象可以直接使用\n      先在此处打印下this--》看看this指向谁 -通过打印得知,this指向当前数组对象 list\n    */\n    // console.log('---this',this)\n    let obj = this.__ob__;\n    if(inserted){\n      obj.observerArray(inserted)//因为args是数组 所以推荐使用observerArray\n    }\n    obj.dep.notify();\n    return result;\n    \n  }\n})","//dep就是发布者\nlet id = 0;\nclass Dep{\n    constructor(){\n        this.id = id++;\n        this.subs = [];//存储依赖列表\n    }\n    //收集watcher->添加依赖\n    depend(){\n        //希望watcher 可以存放 dep -双向记忆\n        // this.subs.push(Dep.target)//Dep.target就是watcher\n        Dep.target.addDep(this);//this 代表当前dep实例\n    }\n    addSub(watcher){\n        this.subs.push(watcher);\n    }\n    //更新watcher ->通知更新\n    notify(){\n        this.subs.forEach(watcher=>{\n            watcher.update()//执行watcher实例的getter()->_update(_render())//其实就是defineProperty中调用了几次set(修改了几个属性),执行几次更新\n        })\n    }\n}\n//添加watcher-->向Dep中添加 \nDep.target = null;\nexport function pushTarget(watcher){\n    Dep.target = watcher;\n    // console.log('---Dep.target',Dep.target)\n}\n//删除watcher\nexport function popTarget(){\n    Dep.target = null;\n    // console.log('---popTarget.target',Dep.target)\n}\nexport default Dep;","/**需要劫持的类型分两种\n * 1) 对象: 利用Object.defineProperty \n *    -缺点:只能对对象中的一个属性进行劫持\n *    -遍历:{a:1,b:2,c:3}   \n *    -递归:{a:{b:1}} get set\n * 2) 数组:方法函数劫持,重写数组方法 push unshift pop splice\n *    \n * **/\nimport {ArrayMethods} from './arr'\nimport Dep from './dep'\n//对外暴漏劫持对象方法\nexport function observer(data) {\n  // console.log('---observer', data);\n  if (typeof data != 'object' || data == null) {\n    return data; //若data不是对象 或者为null 则不需要劫持\n  }\n  //1.对象 通过一个类进行劫持\n  return new Observer(data)\n}\nclass Observer {\n  //vue2 通过defineProperty 缺点:只能对对象中的一个属性进行劫持\n  constructor(value) { //构造器\n     /**给value上新增一个属性__obj__,值为Observer当前实例对象,\n     * 这样在劫持的data中都会有一个不可枚举的属性__obj__,可枚举性决定了这个属性能否被for…in查找遍历到\n     * 该属性直接指向当前observer实例对象（则可以直接使用observer实例上的方法）\n     * **/\n      Object.defineProperty(value,\"__ob__\",{\n        enumerable:false,//不能枚举\n        value:this\n      })\n      //给所有对象类型增加一个dep []\n      this.dep = new Dep();//给observer实例对象添加dep -注意 1){} 2[] 不是给里面的属性添加dep\n\n    if(Array.isArray(value)){//数组对象劫持方法\n      value.__proto__ = ArrayMethods;\n      //如果是数组对象 [{a:1},{b:2}]\n      this.observerArray(value)\n    }else{\n      this.walk(value) //遍历非数组对象\n    }\n  }\n  //遍历非数组对象 进行劫持\n  walk(data) {\n    let keys = Object.keys(data) //{a:{n:1},list:[1,2,3],arr:[{n:1,m:2}]} ->[a,list,arr]\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let value = data[key];\n      defineReactive(data, key, value); //对data中的属性取值和赋值时的操作和处理\n    }\n  }\n  //遍历数组对象 进行劫持\n  observerArray(value){//value=[{a:1},{b:2}]\n    // console.log('--value',value,value.length)\n    for(let i=0;i<value.length;i++){\n      observer(value[i]);//单独劫持数组中的每个对象\n    }\n  }\n}\n//对对象中的属性进行拦截和处理\nfunction defineReactive(data, key, value) {\n  let childDep = observer(value); //对value进行递归 深度代理-> 最初的data可能是{a:{b:1}} 若value值依然是对象 则继续重复劫持该对象--直到值为普通数据\n  // console.log('-childDep1',childDep)\n  let dep = new Dep();//给每一个属性添加一个dep\n  Object.defineProperty(data, key, {\n    get() { //外部调用data.key时触发get方法  -此时需要收集依赖\n      if(Dep.target){//此时target如果有 则是一个watcher,Dep.target是调用了new Watcher()时，构造器调用Watcher的get()添加的,get方法中,先给Dep.target赋值，再调用更新和渲染方法,再将Dep.target=null\n        dep.depend();// 往dep的存储依赖列表subs中存入watcher  --原data中 watcher放dep & dep放watcher 如:data={arr:[1,2,3]}, 对arr对象添加dep(dep中有watcher,watcher中有dep)\n        if(childDep.dep){//childDep.dep是调用 new Observer()时,构造器添加的(new Dep),dep刚new出来，dep只有id 和空数组subs\n          childDep.dep.depend()//数组收集 -当前属性的dep 中添加watcher 如:data={arr:[1,2,3]}, 1 2 3 添加dep(dep中有watcher(通过subs),watcher中有dep(通过deps和depsId))\n        }\n        // console.log('-childDep',value,childDep)\n      }\n      // console.log('--get')\n      // console.log('get Dep',dep);\n      return value;\n    },\n    set(newValue) {\n      // console.log('----set')\n      if (newValue === value) return; //两次内容一样 不做处理\n      observer(newValue)//修改的value也要代理（如 a:{b:1}===> a:{c:1}）,值{c:1}也需要被代理\n      value = newValue; //否则将新值赋值给旧值\n      dep.notify();//如果修改数据 则调用dep的更新方法，该方法会将subs中的每一个watcher进行更新（调用watcher.update,而update就是调用了watcher的getter,getter= new Watcher()时传入的updateComponent函数=vm._update(vm._render())）\n    }\n  })\n}\n","//1)通过这个watcher类 实现更新 --订阅者\n//new watcher(vm,updateComponent,()=>{},true)\n\nimport { nextTick } from \"../utils/nextTick\";\nimport { popTarget, pushTarget } from \"./dep\";\n\n//因为每个组件 都有一个watcher ,为了区分 则需要一个唯一标识 id\nlet id = 0;\nclass watcher {\n    /**\n     * \n     * @param {*} vm -当前vue实例\n     * @param {*} exprOrfn  -传入的某个表达式 ：表达式：1） 用来更新视图的方法updateComponent   2）需要watch的属性\n     * @param {*} cb \n     * @param {*} options \n     */\n    constructor(vm, exprOrfn, cb, options) {\n        // console.log('---watcher 构造器执行',id);\n        //1)\n        this.vm = vm;\n        this.exprOrfn = exprOrfn;\n        this.cb = cb;\n        this.options = options;\n        this.id = id++;\n        this.deps = [];//watcher 存放dep\n        this.depsId = new Set();//存放depId\n        this.user = !!options.user;//转为boolean 该watcher是否是用户创建的\n        //2)判断\n        if (typeof exprOrfn === 'function') {\n            this.getter = exprOrfn;//用来更新视图\n        }else{//watch时 传入的exprOrfn可能是属性c1,也可能是c1.c2.c3 此时this.getter 就是用户返回该属性值的函数\n            /** \n             * watch 的属性  如data中有属性{a:1,b:2,c:3,d:4}, watch:{a:fn1,b:fn2},其中watch的属性 a,b 在书写时都是字符串\n             * 也可能存在data中{c:{c:{c:100}}},需要watch最里面一层的c watch:{\"c.c.c\":fn}\n            */\n            this.getter = function(){//属性 字符串\n                let path = exprOrfn.split('.') //如处理\"c1.c2.c3\"\n                let obj = vm;\n                for (let i=0;i<path.length;i++){//[c1,c2,c3]\n                    obj = obj[path[i]];// 循环3次 第一次此处obj= vm[c1],第二次循环 obj= vm[c1][c2],第三次循环 obj = vm[c1][c2][c3]\n\n                }\n                return obj;\n            }\n        }\n        //更新视图\n        this.value = this.get();//保存watch初始值\n    }\n    //watcher放dep & dep放watcher\n    addDep(dep) {\n        //1.去重\n        let id = dep.id;\n        if (!this.depsId.has(id)) {\n            this.deps.push(dep);\n            this.depsId.add(id);\n            //dep中放watcher\n            dep.addSub(this);\n        }\n    }\n    //更新方法（ps：watcher的第一次执行 走get方法 以后的更新都走run方法）\n    run() {// watch时会传入 old 和 new\n        // this.get()\n        //写 watch的完善，加入old和new值时才需要换成下面写法 在那之前 都是上面一行\n        let value = this.get();//新值\n        let oldValue = this.value;//watch初始化的时候执行了get(),获取的是旧值\n        this.value = value;//新值替换\n        //执行handler(cb) 这个是用户的watcher\n        if(this.user){\n            this.cb.call(this.vm,value,oldValue);//执行watch的回调 并且将新值和旧值传入-这行写完直接去watch.html页面 给watch a的回调添加 newValue 和 oldValue，若发现多执行了一次，则需要将flushWatcher中的item.cb()删除 因为我们在这里执行了cb\n        }\n        \n    }\n    //初次渲染-获取对象的值\n    get() {\n        //添加watcher\n        pushTarget(this);//this就是一个watcher实例 初次渲染(第一次调用vm._update(vm._render())之前，添加watcher\n        /**\n         * 渲染页面 调用传入的updateComponent 即为：vm._update(vm._render()),其中_s(msg),会调用vm.msg 即调用observe/index.js defineReactive中的get()方法,此时若data中有多个属性被调用，\n         * 则都执行get方法之后才会执行后面的popTarget -->将Dep.target置为null\n         * */\n        const value = this.getter();//旧值\n\n        //初次渲染（第一次调用vm._update(vm._render())）之后 删除watcher\n        popTarget();\n        return value;\n    }\n    //更新-对象的更新\n    update() {\n        // this.get();\n        //注意:不要每次数据更改后，都调用更新-考虑使用缓存\n        queueWatcher(this);\n    }\n}\nlet queue = [];//将需要批量更新的watcher 存放到一个队列中\nlet has = {};\nlet pending = false;\nfunction flushWatcher() {\n    queue.forEach(item => {\n        item.run();//执行watcher的run()->this.get()->1）添加watcher 2）调用vm._update(vm._render()) 3）删除watcher\n        //item.cb();//part2://执行new Watcher时传入的回调方法,更新完视图之后 用户在页面new Vue()实例的update函数中写了什么 就执行什么 -在完善watch时这行注释,因为在run方法中执行了该cb回调\n        //或者完善watch时\n        if(!item.user){\n            item.cb();\n        }\n    })\n    queue = [];\n    has = {};\n    pending = false;\n}\nfunction queueWatcher(watcher) {//每个组件都是同一个watcher\n    let id = watcher.id;\n    // console.log('--watcher.id', watcher)\n    //通过id 去重 \n    if (has[id] == null) {\n        //队列处理 将watcher放入队列中\n        queue.push(watcher);\n        has[id] = true;//\n        //-节流 -一定时间内触发多次，只触发第一次\n        if (!pending) {\n            // console.log('---截流')\n            // setTimeout(()=>{//异步 等待同步代码执行完毕之后再执行该异步方法\n            //     console.log('---setTime',queue)\n            //     queue.forEach(item=>item.run())\n            //     queue = [];\n            //     has = {};\n            //     pending = false;\n            // },0)//通过nextTick实现更优化\n            /**\n             * nextTick相当于定时器\n             */\n            nextTick(flushWatcher)\n        }\n        // console.log('---zhunbeigai pending')\n        pending = true;\n\n    }\n}\nexport default watcher\n\n/**\n * 收集依赖\n * vue \n * dep:就是data:{name,msg}中有多少个属性,则dep中有多少个 ，dep和data中的属性是一一对应的\n * watcher:就是data中的属性，在视图上用了几个,dep的subs中就有几个watcher  -（第一个版本中 同时修改两个属性，msg,name subs中的两个watcher是同一个 subs=[watcher0,watcher0]）\n * dep与watcher的关系： 1对多 dep.name = [w1,w2] (后面考虑computed 其实是多对多)\n */\n\n/**\n * nextTick 原理 -优化\n * 1.创建nextTick()\n */","\nimport { nextTick } from \"./utils/nextTick\"\nimport { observer } from \"./observe/index\"\nimport Watcher from \"./observe/watcher\"\n\n/**初始化数据的文件 */\nexport function initState(vm){\n  let opts = vm.$options\n  // console.log('--opts',opts)\n  if(opts.data){//注意一定要先初始化data 再初始化watch\n    initData(vm)\n  }\n  if(opts.watch){\n    initWatch(vm)\n  }\n  //判断\n  if(opts.props){\n    initProps(vm)\n  }\n\n  if(opts.computed){\n    initComputed(vm)\n  }\n  if(opts.methods){\n    initMethods(vm)\n  }\n}\nfunction initProps(vm){\n}\n//part3:实现watch的第一步 -填充该方法\nfunction initWatch(vm){\n   //1. 获取watch\n   let watch = vm.$options.watch;\n   console.log('----initWatch',watch)\n   //2. 遍历 --因为watch的写法 属性: 后面可以跟 1)函数   2）数组   3）对象    4）字符串\n   for(let key in watch){\n    //2.1 获取 属性对应的值 判断\n    let handler = watch[key];//handler 可能是1)函数   2）数组   3）对象    4）字符串\n    if(Array.isArray(handler)){//数组 (数组每一项都是方法)\n      handler.forEach(item=>{\n        createWatcher(vm,key,item)\n      })\n    }else{//3）对象    4）字符串  1)函数\n    //3. 创建一个函数来处理\n      createWatcher(vm,key,handler)\n    }\n   }\n}\n\n/**\n * 格式化处理 -处理好handler函数实际内容 再通过vm.$watch方法执行\n * @param {*} vm \n * @param {*} exprOrfn //vm.$watch(()=>{return 'a'})//返回值“a”就是watch上的属性 也就是说 第二个参数 可能是属性名称，也可能是一个表达式（该表达式会返回属性名）\n * @param {*} handler \n * @param {*} options  如：user=false\n */\nfunction createWatcher(vm,exprOrfn,handler,options={}){\n  //接initWatch\n  //3.1 处理handler\n  if(typeof handler ==='object'){ //{handler:function(){},deep:true}\n    options = handler//用户的配置项目 {handler:function(){},deep:true}\n    handler = handler.handler;\n  }\n  if(typeof handler ==='string'){//'aa' 是实例上的方法\n    handler = vm[handler];//将实例上的方法作为handler  方法的代理和data一样\n  }\n  //其他是函数\n  //watch 最终处理 通过$watch 这个方法 -该方法需要手动添加 (stateMixin()函数中)\n  return vm.$watch(vm,exprOrfn,handler,options)\n\n}\n//part5 computed第一步 继续编写该方法\nfunction initComputed(vm){\n  let computed = vm.$options.computed;\n  console.log('--initComputed',computed)\n}\nfunction initMethods(){\n\n}\n//vue2 对data初始化\n/**\n * data对象情况区分：--为了解决作用域问题\n * 1）根实例是对象 {}\n * 2) 组件是函数 (){} --是为了保证组件的独立性和可复用性\n */\nfunction initData(vm){\n  // console.log('---对data进行初始化',vm);\n  let data = vm.$options.data;\n  //获取data数据\n  data = vm._data = typeof data =='function'?data.call(vm):data;//1. 注意this 2.为了方便获取 将原option中data的值直接绑定到vm._data中\n  //对数据进行劫持\n  //将data上的所有属性代理到vm实例上\n  for(let key in data){\n    //自定义函数proxy \n    proxy(vm,'_data',key)\n  }\n  observer(data)// 数据劫持！！！！  dep,watcher都在劫持的时候处理 注意 此时拿到的data可能是以下情况 (1）对象  (2) 数组  {a:{n:1},list:[1,2,3],arr:[{n:1,m:2}]}    \n}\n//用于将代理 vm._data属性中的内容 全都直接放到vm中,key依然为原data中的key=> vm._data={a:1,b:2} 代理处理后为:vm.a=1 vm.b=2\nfunction proxy(vm,source,key){\n  Object.defineProperty(vm,key,{//定义vm中的key属性,vm.key时返回 vm._data.key的值\n    get(){\n      return vm[source][key]\n    },\n    set(newValue){//vm.key=newValue时 相当于调用vm._data.key = newValue\n      vm[source][key] = newValue;\n    }\n  })\n}\n\n\n\n\n\nexport function stateMixin(vm){\n  //队列处理 1)是vue自己的nextTick()   2)用户自己函数cb\n  vm.prototype.$nextTick = function (cb){\n    nextTick(cb);//此时的nextTick就是utils/nextTick暴漏的方法\n  },\n  /**\n   * \n   * @param {*} exprOrfn 属性\n   * @param {*} handler 处理函数\n   * @param {*} options 其他配置项\n   */\n  vm.prototype.$watch = function(vm,exprOrfn,handler,options={}){\n    console.log(exprOrfn,handler,options)\n    //实现watch 方法  利用new watcher -渲染的时候走渲染的watcher  $watch走watch的watcher-利用user false\n    //watch 的核心就是watcher -完善watch的第一步\n    let watcher =  new Watcher(\n      vm,exprOrfn,handler,\n      {...options,user:true}//注意最后的options合并 添加了user:true,代表此时watch是用户添加的属性，该合并在完善watch时再添加\n      );\n    console.log('----watcher',watcher)\n    if(options.immediate){\n      handler.call(vm)//如果有immediate 则立即执行handler函数\n    }\n  }\n}\n","/**\n * patch方法就是将虚拟dom->真实dom -part4diff算法时 patch方法内容整体重写 原内容放入if(oldVnode.nodeType ===1){中\n * @param {*} oldVnode 原容器\n * @param {*} vnode 虚拟dom\n */\nexport function patch(oldVnode,vnode){\n    //第一次渲染 oldVnode 是一个真实的DOM\n    if(oldVnode.nodeType ===1){//nodeType真实dom节点的节点类型->1:元素;2:属性;3:文本;4:注释\n        // vnode=>真实dom\n        //1)创建新的DOM\n        let el = createEl(vnode);\n        // console.log('---真实domel',el);\n        //2)替换 2.1）获取父节点 2.2）插入新dom 2.3）删除旧元素\n        let parentEl = oldVnode.parentNode;// body\n        parentEl.insertBefore(el,oldVnode.nextsibling);//在旧节点的下一个兄弟节点 插入新dom\n        parentEl.removeChild(oldVnode);//删除旧元素\n        return el;//返回新dom\n    }else{//两个vnode -diff\n        console.log('---diff中比较两个节点',oldVnode,vnode);\n        //1. 元素不是一样\n        if(oldVnode.tag !== vnode.tag){\n          return oldVnode.el.parentNode.replaceChild(createEl(vnode),oldVnode.el);\n        }\n        //2. 标签一样 text 属性<div>1</div>  <div>2</div> tag:undefined\n        if(!oldVnode.tag){//旧节点不是标签 就是普通文本\n            console.log('---旧元素不是节点')\n            if(oldVnode.text !== vnode.text){//旧节点文本内容和新节点文本内容不相等\n              return  oldVnode.el.textContent = vnode.text;\n            }\n        }\n        //2.1 属性 （diff比较属性，前提是标签是一样的）<div id=\"a\">1</div> <div id=\"b\">2</div>\n        //方法 1).直接复制\n        let el = vnode.el = oldVnode.el;\n        updataRpors(vnode,oldVnode.data)//将新节点的属性，通过与旧节点属性比较厚 添加到真实节点中\n        //diff 新旧元素的 子元素 （比较两个元素的子元素内容）\n        let oldChildren = oldVnode.children||[];\n        let newChildren = vnode.children||[];\n        //1) 旧元素有子元素 新元素也有\n        //2）旧元素有子元素 新元素没有\n        //3）旧元素没子元素 新元素有\n        if(oldChildren.length>0 && newChildren.length>0){ //1) 旧元素有子元素 新元素也有\n            console.log('---新旧元素都有儿子节点')\n            //创建方法，用于比较新旧元素 并更新结果到el -为了验证该方法 此时将index.js中两个元素模版内容改成ul+li的结构\n            updataChild(oldChildren,newChildren,el)\n        }else if(oldChildren.length>0){//2）旧元素有子元素 新元素没有\n            el.innerHTML ='';//删除旧元素的子节点\n        }else if(newChildren.length>0){//3）旧元素没子元素 新元素有\n            for(let i=0;i<newChildren.length;i++){\n                let child = newChildren[i];\n                //子元素转为真实dom之后 添加到真实dom el中\n                el.appendChild(createEl(child))\n            }\n        }\n\n    }\n}\n/**\n * 两个包含子元素的节点 比较内容 --p34 0:05:20\n * vue diff算法 做了很多优化  旧<li>1</li>  新 <li>2</li> \n * dom操作元素 常用的逻辑:\n * 尾部添加 或者 头部添加 或者 倒序和正序的方式\n * vue2中采用双指针的方式遍历\n *  1)创建双指针\n * 比较规则:双指针比对\n */\nfunction updataChild(oldChildren,newChildren,parent){\n    //1.创建旧元素头指针、尾指针\n    let oldStartIndex = 0;//旧的开头索引\n    let oldStartVnode = oldChildren[oldStartIndex];//旧的开头元素\n    let oldEndIndex = oldChildren.length -1;//旧的结尾索引\n    let oldEndVnode = oldChildren[oldEndIndex];//旧的结尾元素\n\n    //1.创建新元素头指针、尾指针\n    let newStartIndex = 0;//新的开头索引\n    let newStartVnode = newChildren[newStartIndex];//新的开头元素\n    let newEndIndex = newChildren.length -1;//新的结尾索引\n    let newEndVnode = newChildren[newEndIndex];//新的结尾元素\n\n    //创建旧元素的映射表 -p35 19:15\n    function makeIndexByKey(child){\n        let map ={};\n        child.forEach((item,index)=>{\n            if(item.key){\n                map[item.key] = index;\n            }\n        })\n        return map;\n    }\n    let map = makeIndexByKey(oldChildren);//todo\n\n\n    //当旧元素头指针<=尾指针 且 新元素头指针<=尾指针:新元素的头部和旧元素的头部做比较\n    while(oldStartIndex <= oldEndIndex && newStartIndex<= newEndIndex){\n        //比对子元素\n        //头部比较:注意头部这个元素是否是同一个元素\n        if(isSameVnode(oldStartVnode,newStartVnode)){//若果新旧元素的头部是同一元素\n            console.log('---新旧元素的头部是同一个元素')\n            //递归比较\n            patch(oldStartVnode,newStartVnode)//则patch比较元素的内容 将差异的部分添加进去\n            //头部指针后移\n            oldStartVnode = oldChildren[++oldStartIndex]\n            newStartVnode = newChildren[++newStartIndex]\n        }else if(isSameVnode(oldEndVnode,newEndVnode)){\n            patch(oldEndVnode,newEndVnode);\n            oldEndVnode = oldChildren[--oldEndIndex]\n            newEndVnode = newChildren[--newEndIndex]\n        }else if(isSameVnode(oldStartVnode,newEndVnode)){//旧元素头 和新元素尾 交叉比较\n            patch(oldStartVnode,newEndVnode);\n            oldStartVnode = oldChildren[++oldStartIndex];\n            newEndVnode = newChildren[--newEndIndex];\n        }else if(isSameVnode(oldEndVnode,newStartVnode)){//旧元素尾 和新元素头 交叉比较\n            patch(oldEndVnode,newStartVnode);\n            oldEndVnode = oldChildren[--oldEndIndex];\n            newStartVnode = newChildren[++newStartIndex];\n        }\n        //面试题:为什么要添加key -答案在此处\n        else{/*新旧元素的儿子之间没有任何关系，\n            使用暴力对比-用新元素跟旧元素中的每一个做比较\n            1）如果新元素在旧元素中不存在,则将新元素转成真实dom 插入在旧元素的真实dom前面\n            2）如果新元素在旧元素中存在，则将旧元素转成真实dom,移到该旧元素的前面，然后比较新旧元素(patch)，这样就可以把新元素不一样的地方更新上去了\n            新元素指针位移\n            */\n            //1.创建旧元素的映射表\n            //2.从旧元素映射表中查找新的元素是否存在\n            let mapIndex = map[newStartVnode.key];\n            if(mapIndex==undefined){//新元素在旧元素中不存在\n                //将该元素转成真实dom，添加到旧元素的真实dom前面\n                parent.insertBefore(createEl(newStartVnode),oldStartVnode.el)\n            }else{//新元素在旧元素中存在\n                //1.获取到旧元素（需要移动的元素）\n                let moveVnode = oldChildren[mapIndex];\n                oldChildren[mapIndex] =null;//防止数组塌陷 移走的位置用null补位\n                parent.insertBefore(moveVnode.el,oldStartVnode.el);//将需要移动的旧元素的真实dom 插入到当前指针对应元素的真实dom前面\n                //问题:插入的元素可以还有子节点 -patch比较\n                patch(moveVnode,newStartVnode)\n            }\n            //新元素指针位移\n            newStartVode = newChildren[++newStartIndex]\n        }\n    }\n    // 添加多余的儿子 ---理论上来说 到这个位置 新元素的头指针应该=新元素的尾指针 旧元素的头指针应该=旧元素的尾指针\n    // 如果上面两个条件谁不满足 就说明 还有元素没有比较到 是多出来的\n    if(newStartIndex<=newEndIndex){//新元素的头指针 <= 尾指针 -有新的元素是多出来的，则将新元素添加到parent(旧元素的真实dom)中\n        for(let i= newStartIndex;i<newEndIndex;i++){\n            parent.appendChild(createEl(newChildren[i]))\n        }\n    }\n    /*此时 旧元素中包含了旧元素 以及patch新元素之后的旧元素，需要将多余的旧元素删除\n    如 旧元素 a,b,c\n       新元素 a,d,f,c\n       按照上面的比较处理之后就是 patch之后的a,null,d,b,f,patch之后的c,null\n       此时需要把null都删除\n    */\n    if(oldStartIndex<=oldEndIndex){//新元素的头指针 <= 尾指针 -有新的元素是多出来的，则将新元素添加到parent(旧元素的真实dom)中\n        for(let i= oldStartIndex;i<oldEndIndex;i++){\n           //注意null\n           let child = oldChildren[i];\n           if(child!=null){\n            parent.removeChild(child.el);//从当前真实dom中删除该旧dom\n           }\n        }\n    }\n\n}\n//判断是否是同一个元素 -元素类型和key都相等\nfunction isSameVnode(oldContext,newContext){\n    return (oldContext.tag === newContext.tag) && (oldContext.key === newContext.key)\n}\n/*\n将节点的属性 添加到真实节点中 -如 模版为<div id=\"a\" style=\"color:red\">张三</div>\n* vnode:虚拟节点 \n{\n  tag:'div',\n  key:undefined,\n  text:文本内容,\n  el:真实节点,\n  data:{\n    id:'a',\n    style:{\n       color:'red'\n    }\n  }//节点的属性对象\n  children:{\n    tag:undefined,\n    key:undefined,\n    text:'张三',\n    el:真实节点,\n    data:{id:'a'}//节点的属性对象\n    children:undefined\n  }\n\n}\n*/\nfunction updataRpors(vnode,oldProps={}){//第一次\n    console.log('----updataRpors',vnode)\n    let newProps = vnode.data || {};//获取当前新节点的属性\n    let el = vnode.el;//获取当前新节点的真实节点\n    //比较处理新旧节点属性的不同-start\n    //1.某个属性 老的有该属性，新的没有\n    for(let key in oldProps){\n        if(!newProps[key]){\n            //删除真实节点中的该属性\n            el.removeAttribute(key);\n        }\n    }\n    //2.样式的处理\n    //2.1 旧虚拟节点的样式 style:{color:red}  新的虚拟 style:{background:red}\n    let newStyle = newProps.style||{};\n    let oldStyle = oldProps.style||{};\n    for(let key in oldStyle){\n        if(!newStyle[key]){//旧虚拟节点有该样式 新虚拟节点么有\n            el.style = ''//删除了新节点上真实节点的样式- 如果有多个不担心全删了，因为下面的3会将新节点的style又放回到了新节点真实节点上\n        }\n    }\n    // console.log('--el',el)\n    //比较处理新旧节点属性的不同-end\n    //3.新虚拟dom中有属性，而旧虚拟dom无属性\n    for(let key in newProps){\n        if(key===\"style\"){//样式属性\n            for(let styleName in newProps.style){\n               el.style[styleName] = newProps.style[styleName] //真实节点添加属性的方法 el.style['height']='14px'\n            }\n        }else if(key ===\"class\"){//样式类属性\n            el.className = newProps.class;//真实节点添加样式类的方法\n        }else{//其他属性\n            el.setAttribute(key,newProps[key]);\n        }\n    }\n}\n//创建真实dom\nexport function createEl(vnode){//vnode:{tag,text,data,children}---{tag: 'div', data: {…}, key: undefined, children: Array(2), text: undefined}\n    let {tag,children,key,data,text} = vnode;\n    if(typeof tag =='string'){//标签\n        vnode.el = document.createElement(tag);\n        // updataRpors(vnode)//添加标签的属性\n        //children->遍历子节点 继续创建dom\n        if(children.length>0){\n            children.forEach(child => {\n                vnode.el.appendChild(createEl(child))\n            });\n        }\n    }else{//文本\n        vnode.el = document.createTextNode(text);\n    }\n    return vnode.el;//此时的el已经是真实dom\n}\n/**\n * vue 渲染流程：\n * 1） 数据初始化\n * 2） 对模版进行编译\n *     模版内容-> ast语法树->变成render函数\n *     ->render函数执行后得到vnode ->变成真实dom->放到页面\n *    \n */","import watcher from \"./observe/watcher\";\nimport { patch } from \"./vnode/patch\";\n\n/**\n * \n生命周期文件\n */\nexport function mounteComponent(vm,el){\n    //源码--页面加载之前 调用beforeMounted\n    callHook(vm,\"beforeMounted\");\n    //part1中手动调用了更新页面方法-vm._update(vm._render())\n    //vm._update(vm._render())//1)vm._render将render函数变成vnode 2)vm._update 将vnode变成真实dom 放到页面上 -本次操作即为页面加载\n    //part2中 通过observe/watcher\n    let updateComponent = ()=>{\n        vm._update(vm._render())\n    }\n    //new watcher时调用了构造器，而构造器中默认调用了get(),get()又调用了传入的updateComponent -part2:这个watcher是用于渲染的 目前没有任何功能\n    new watcher(vm,updateComponent,()=>{\n        callHook(vm,'updated')//生命周期 updated的发布\n    },true)\n    callHook(vm,\"mounted\");\n\n}\n/**\n * \n * @param {*} Vue \n */\nexport function lifecycleMixin(Vue){\n    Vue.prototype._update = function(vnode){//vnode => 真实的dom\n        // console.log('---vnode',vnode)\n        let vm = this;\n        //参数 1）容器节点 2)vnode\n        //1.vm.$el 真实的dom\n        //2.区分是否是首次 非首次：更新\n        let prevVnode = vm._vnode;//如果是首次 值为null\n        if(!prevVnode){//没有_vnode 表示是首次\n            vm.$el = patch(vm.$el,vnode);//比较原来的真实dom 和本次的vnode,最后转成真实dom返回 存入vm的$el上\n            vm._vnode = vnode;//vnode(上一次的真实dom)存入vm的_vnode\n        }else{\n            vm.$el = patch(vm.$el,vnode);//vue中的patch方法就是将虚拟dom->真实dom\n        }\n    } \n}\n//1)render()函数 ==》vnode ==》真实dom\n\n//生命周期调用（订阅发布的模式）\nexport function callHook(vm,hook){\n    // console.log('---',hook);\n    const handles = vm.$options[hook]// 如hook为created, 则handles=[a,b,created]\n    // console.log('---handles',handles);\n    if(handles){\n        for(let i=0;i<handles.length;i++){//性能最好的就是这种原始for\n            handles[i].call(this);//改变生命周期中的this指向问题\n        }\n    }\n}","//Vue所有初始化的内容\nimport { compileToFunction } from \"./compile/index\";\nimport { initState } from \"./initState\";\nimport { callHook, mounteComponent } from \"./lifecycle\";\nimport { mergeOptions } from \"./utils/index\";\nexport function initMixin(Vue){\n  //_init方法放到Vue原型链上\n  Vue.prototype._init = function(options){\n    // console.log('_initMixin中Vue原型链上的',options);\n    let vm = this\n    // vm.$options = options//将参数帮到实例上\n    vm.$options = mergeOptions(Vue.options,options);//将Vue上原有的option属性和本次传入的option合并 重新放到实例对象上\n    callHook(vm,'beforeCreated');//初始化之前\n    //初始化状态\n    initState(vm);\n    callHook(vm,'created');//初始化之后\n    //渲染模版\n    if(vm.$options.el){\n      //调用vm实例的$mount方法--此方法需要定义\n      vm.$mount(vm.$options.el)\n    }\n  }\n  //创建$mount方法\n  Vue.prototype.$mount = function(el){\n    // console.log('---el',el)\n    let vm = this;\n    el = document.querySelector(el);//根据id获取当前绑定的根节点-object\n    vm.$el = el;//将根节点绑定到vm实例的$el属性上\n    // console.log('---el',typeof el);\n    let options = vm.$options;\n    if(!options.render){//new Vue的时候没有指定render函数\n      let template = options.template;\n      if(!template && el){//new Vue的时候没有指定模版，且存在根节点\n        el = el.outerHTML; //string-[1]\n        //获取到el的最终目的是为了变成render函数\n        //将el--->ast语法树 ast语法树--->render函数\n        let render = compileToFunction(el);\n        // console.log('---render',render);\n        //1) 将render 函数变成vnode\n        //2) 将vnode变成真实DOM 放到页面上\n        options.render = render;//将拿到的render函数放到实例对象options的render中\n        //---todo 将虚拟的dom变为真实dom\n\n      }\n\n    }\n    //挂载组件--调用生命周期文件中的挂载组件方法\n    mounteComponent(vm,el)//vm._update(vm._render)\n  }\n}\n/**\n * [1].获取到el之后要做的事情是\n *     1)变成ast语法树\n *     2)生成render()函数\n *     3)render函数变成虚拟dom\n *     4)\n \n * }\n */\n","\n//将render函数变成vnode(虚拟节点)\nexport function renderMixin(Vue){\n    /**\n     * 标签解析\n     */\n    Vue.prototype._c = function(){\n        //创建标签\n        return createElement(...arguments);\n    }\n    /**\n     * 文本解析\n     */\n     Vue.prototype._v = function(text){\n        return createText(text)\n    }\n    /**\n     * 变量解析 _s(name) -->{{name}}\n     */\n     Vue.prototype._s = function(val){\n        // console.log('---_S',val);\n        return val ==null?'':(typeof val ==='object')?JSON.stringify(val):val\n    }\n    Vue.prototype._render = function(){\n        let vm = this;\n        let render = vm.$options.render;//获取实例上的render(该render最终是ast语法树转换成的render函数)\n        let vnode = render.call(this)//执行render函数,将当前vm实例作为render中的this\n        // console.log('---vnode',vnode)\n        return vnode;\n    }\n}\n//创建元素的方法\n/**\n * \n * @param {*} tag \n * @param {*} data \n * @param  {...any} chiildren \n */\nfunction createElement(tag,data={},...children){\n    return vnode(tag,data,data.key,children)\n}\n//创建文本\nfunction createText(text){\n    return vnode(undefined,undefined,undefined,undefined,text)\n}\nfunction vnode(tag,data,key,children,text){\n    return {\n        tag,data,key,children,text\n    }\n}\n/**\n * vnode节点\n * {\n *  tag,\n * text,\n * chiildren\n * }\n */","//项目入口文件\nimport { compileToFunction } from './compile/index.js'\nimport { initGlobalApi } from './global-api/index.js'\nimport {initMixin} from './init.js'\nimport { stateMixin } from './initState.js'\nimport { lifecycleMixin } from './lifecycle.js'\nimport { renderMixin } from './vnode/index.js'\nimport {createEl} from './vnode/patch'//part4 diff时引入\nfunction Vue(options){//通过new Vue调用\n  // console.log('---100 -w 的作用 自动更新dist的vue')\n  // console.log(options)\n  //初始化\n  this._init(options)\n}\ninitMixin(Vue)//调用该方法会向Vue对象的原型链上添加_init方法——对状态进行初始化\nlifecycleMixin(Vue)//对生命周期进行初始化\nrenderMixin(Vue)//添加vm._render方法\nstateMixin(Vue)//给vm添加$nextTick\n\n//全局方法 vue.mixin Vue.component Vue.extend\ninitGlobalApi(Vue);//初始化全局方法\n\n//-----part4 diff start-----\n// part4.1 不比较子节点内容时的模版 -div\n// let vm1 = new Vue(({data:{name:'张三'}}));//创建vue实例对象\n// let render1 = compileToFunction(`<div id=\"a\" style=\"color:red;font-size:80px\"></div>`);//将真实dom的字符串形式转成render函数\n// let vnode1 = render1.call(vm1);//利用render函数 解析vue实例对象中的数据 生成虚拟dom\n// document.body.appendChild(createEl(vnode1))//虚拟dom ->真实dom  将真实dom追加到body中\n\n// //数据更新\n// let vm2 = new Vue(({data:{name:'李四'}}));//创建vue实例对象\n// let render2 = compileToFunction(`<div id=\"b\" style=\"color:blue\">{{name}}<div>我还有想说的问题呢</div></div>`);//将真实dom的字符串形式转成render函数 ---part4发现compileToFunction有问题 去改动\n// let vnode2 = render2.call(vm2);//利用render函数 解析vue实例对象中的数据 生成虚拟dom\n// document.body.appendChild(createEl(vnode2))//虚拟dom ->真实dom  将真实dom追加到body中\n\n// // part4.2 比较子节点内容时的模版-ul+li\n// let vm1 = new Vue(({data:{name:'张三'}}));//创建vue实例对象\n// let render1 = compileToFunction(`\n//   <ul>\n//     <li key=\"a\" style=\"background:red\">a</li>\n//     <li key=\"b\" style=\"background:green\">b</li>\n//     <li key=\"c\" style=\"background:blue\">c</li>\n//   </ul>\n// `);//将真实dom的字符串形式转成render函数\n// let vnode1 = render1.call(vm1);//利用render函数 解析vue实例对象中的数据 生成虚拟dom\n// document.body.appendChild(createEl(vnode1))//虚拟dom ->真实dom  将真实dom追加到body中\n\n// //数据更新\n// let vm2 = new Vue(({data:{name:'李四'}}));//创建vue实例对象\n// let render2 = compileToFunction(`\n//   <ul>\n//     <li key=\"d\" style=\"background:red\">d</li>\n//     <li key=\"e\" style=\"background:green\">e</li>\n//     <li key=\"f\" style=\"background:blue\">f</li>\n//   </ul>\n// `);\n// let vnode2 = render2.call(vm2);//利用render函数 解析vue实例对象中的数据 生成虚拟dom\n// document.body.appendChild(createEl(vnode2))//虚拟dom ->真实dom  将真实dom追加到body中\n// // patch比对\n// setTimeout(()=>{\n//   patch(vnode1,vnode2)\n// },1000)\n\n//-----part4 diff end-------\nexport default Vue\n\n/**\n * new Vue(options) \n *    ->调用当前vue实例的_init(options)\n *      (前提是在init.js中initMixin方法已定义了Vue.property._init方法\n *       Vue.property._init方法,调用mergeOptions(Vue.options,options),此处的options就是New Vue(options)的参数\n */"],"names":["defaultTagRE","genProps","attrs","str","i","length","attr","name","obj","value","split","forEach","item","key","JSON","stringify","slice","genChildren","el","children","map","child","gen","join","node","type","generate","text","test","tokens","lastindex","lastIndex","match","exec","index","push","trim","code","tag","ncname","qnameCapture","startTagOpen","RegExp","attribute","startTagClose","endTag","parseHTML","html","createASTElement","parent","root","createParent","stack","start","element","charts","replace","end","pop","textEnd","indexOf","startTagMatch","parseStartTag","tagName","endTagMatch","advance","atrr","n","substring","compileToFunction","ast","render","Function","HOOKS","starts","data","parentVal","childVal","hooks","mergeHook","concat","mergeOptions","options","mergeField","initGlobalApi","Vue","Mixin","mixin","callback","pending","flush","cb","timerFunc","Promise","resolve","then","MutationObserver","observe","textNode","document","createTextNode","characterData","textContent","setImmediate","nextTick","oldArrayProtoMethods","Array","prototype","ArrayMethods","Object","create","methods","args","result","apply","inserted","splice","__ob__","observerArray","dep","notify","id","Dep","constructor","subs","depend","target","addDep","addSub","watcher","update","pushTarget","popTarget","observer","Observer","defineProperty","enumerable","isArray","__proto__","walk","keys","defineReactive","childDep","get","set","newValue","vm","exprOrfn","deps","depsId","Set","user","getter","path","has","add","run","oldValue","call","queueWatcher","queue","flushWatcher","initState","opts","$options","initData","watch","initWatch","props","computed","initComputed","console","log","handler","createWatcher","$watch","_data","proxy","source","stateMixin","$nextTick","Watcher","immediate","patch","oldVnode","vnode","nodeType","createEl","parentEl","parentNode","insertBefore","nextsibling","removeChild","replaceChild","updataRpors","oldChildren","newChildren","updataChild","innerHTML","appendChild","oldStartIndex","oldStartVnode","oldEndIndex","oldEndVnode","newStartIndex","newStartVnode","newEndIndex","newEndVnode","makeIndexByKey","isSameVnode","mapIndex","undefined","moveVnode","newStartVode","oldContext","newContext","oldProps","newProps","removeAttribute","newStyle","style","oldStyle","styleName","className","class","setAttribute","createElement","mounteComponent","callHook","updateComponent","_update","_render","lifecycleMixin","prevVnode","_vnode","$el","hook","handles","initMixin","_init","$mount","querySelector","template","outerHTML","renderMixin","_c","arguments","_v","createText","_s","val"],"mappings":"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"}